---
layout: post
title: "JUST testing this theme"
subtitle: "Problems look mighty small from 150 miles up"
date: 2023-01-31 10:45:13 -0400
background: '/img/posts/06.jpg'
---

<p>
    $$
    exp(-0.5 <em>d </em>(1 /1.5^2) )* d
    $$
    d = Distanz zum Routinggraphen
  </p>
  <p>result = Wahrscheinlichkeit</p>
  <p>
    $$
    exp(-0.5 <em>0.5 </em>(1 /1.5^2) )* 0.5 = 0.447420
    $$
  </p>
  <p>
    $$
    exp(-0.5 <em>1 </em>(1 /1.5^2) )* 1 = 0,800737
    $$
  </p>
  <p>
    $$
    exp(-0.5 <em>2 </em>(1 /1.5^2) )* 2 = 1.2323
    $$
  </p>
  <p>
    $$
    exp(-0.5 <em>3 </em>(1 /1.5^2) )* 3 = 1.54025
    $$
  </p>
  <p>
    $$
    exp(-0.5 <em>4 </em>(1 /1.5^2) )* 4 = 1.64445
    $$
  </p>
  <p>
    <img src="inkdrop://file:qyD64gSdf" alt="clipboard.png">
  </p>
  <p>-> wenn letzte zahl bekannt in prozent umrechnen? und dann sagen x prozent von 255</p>
  <p>z.b.</p>
  <p>
    $$
    0.447420 + 0.800737 + 1.2323 + 1.54025 + 1.64445 = 5.665157
    $$
  </p>
  <p>
    $$
    0.447420/5.665157 * 100 = 7.897\%
  </p>
  <p>0.07 * 255 = 17,85</p>
  <p>$$</p>
  <p>
    $$
    1.64445/5.665157 * 100 = 29.0274\%
  </p>
  <p>
    255 * 0.29 = 73,95
    $$
  </p>
  <hr>
  <h1>WRONG FUNCTION!!!!</h1>
  <ul>
    <li><a href="https://www.desmos.com/calculator/txperdvi3y?lang=de">https://www.desmos.com/calculator/txperdvi3y?lang=de</a> -> better</li>
  </ul>
  <h1>Presentation:</h1>
  <ul>
    <li>Marie udn Malaz schreiben -> wie machen wir das morgen</li>
    <li>e#</li>
  </ul>
  <h2>mögliche umsetzung</h2>
  <ul>
    <li>einricthung von github auf dem pc</li>
    <li>clonen des repo</li>
    <li>anlegen einer neuen datei für die concave hülle
      <ul>
        <li>schreiben scriptes</li>
      </ul>
    </li>
    <li>commit &#x26; push des scriptes</li>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
  <hr>
  <h2>einfache variante</h2>
  <ul>
    <li>
      <p>download von map data</p>
    </li>
    <li>
      <p>neues python script erstllen</p>
      <ul>
        <li><strong>concave hull</strong></li>
        <li>libraries laden</li>
        <li>datensatz einladen</li>
        <li>dissolve??</li>
        <li>anwendung der entsprechend</li>
        <li>überprüfung des ergebnisses mittels eines plottes</li>
        <li>rasterisierung</li>
        <li>auschneiden der likeliehood map</li>
      </ul>
    </li>
    <li>
      <p>wenn du fertig bist .. mir zuschicken</p>
    </li>
  </ul>
  <hr>
  <h1>Indoor Positioning</h1>
  <h2>PDR</h2>
  <h2>Likeliehood Map</h2>
  <h3>Current Status</h3>
  <ul>
    <li>basics are working</li>
    <li>some settings are not perfect</li>
    <li>implementation of the right function! -> major point</li>
  </ul>
  <h3>TODO's</h3>
  <h3>Implement other functions</h3>
  <h3>Concave Hull</h3>
  <h2>ML</h2>
  <hr>
  <h2>Funktion:</h2>
  <p>$exp(-0.5 <em>d </em>(1 /1.5^2)* d )$</p>
  <ul>
    <li>buffer distanz konstant halten -> hier kann man ja schon alles einstellen</li>
    <li>nur bei Konvertierung einhalten</li>
  </ul>
  <h3>Current Function</h3>
  <pre><code class="language-python">def conv_buf(l,transform, shape ):
      """Converts list of buffers in vector format to rasterized images with highest value in center of the routing graph and lowest value further away. Using linear scaling.
  
      Args:
          l (_type_): _description_
          transform (_type_): _description_
          shape (_type_): _description_
      """
      # reminder: Wall = 0; Graph = Max
      len_l = len(l)
      # linear scaling with this stepsize -> could be changed later in the function itsself
      step_size = int(round(255 / len_l, 0))
      print("Step Size: " , step_size)
      # generate background with zeros (starting point)
      ras_out = np.zeros(shape, dtype=int)
  
  
      for i in range(len_l):
          ras = rasterio.features.rasterize(
              l[i].geometry,
              out_shape=shape,
              transform=transform,
              fill= 0,
              all_touched=True,
              dtype=rasterio.uint8,
              default_value = step_size)  
          
          ras_out = np.add(ras_out, ras)
  
      print("Values of the output likeliehood map: ", np.unique(ras_out))
      return ras_out
  
  </code></pre>
  <h3>Modified Funciton</h3>
  <ul>
    <li>if else nur dann aufaddieren wenn größer? -> für jedes pixel -> klingt blöd</li>
    <li>Berechnung von Funktion über den gesamten Wertebereich hinweg als liste</li>
    <li>letzter Buffer wird zuerst geaddet
      <ul>
        <li>dann kommt der zweite</li>
        <li>hier wird aber nicht der gesamte werte sondern dieser abzüglich des ersten wertes berechnete -> kann auch schon oben erfolgen</li>
      </ul>
    </li>
    <li>und aufaddiert</li>
  </ul>
  <hr>
  <ul>
    <li>step number + distanz jedes buffers (konstant!!) -> brauche nur die distanz d -> welche ich in eine lsite bei der funktion schreiben lasse</li>
    <li>255 muss der höchste sein</li>
    <li>benötigen anteil von 255</li>
    <li>4 steps + 0.5 m</li>
  </ul>
  <pre><code class="language-python">import math
  
  # liste with values e.g 0 = 1, 0.5 = 0.94; 1 = 0.804
  l = []
  
    for d in distances:
      f =  math.exp(-0.5 * d * (1 /1.5^2)* d )
  
      l.append(int(round(f*255),0))
  
  
  </code></pre>
  <p>l = [255, 240, 205]</p>
  <p>invert</p>
  <p>l = [205,240,255]</p>
  <p>brauche</p>
  <p>l = [205, 35, 15]</p>
  <p>wie geht das technisch</p>
  <p>205</p>
  <p>240 - 205</p>
  <p>255 - 240</p>
  <p>auf normale liste anwenden und dann invertieren</p>
  <p>
    my_list = [1,2,3,5,7,9]
    diff_list = []
    for i in range(1,len(my_list)):
    x = my_list[i] - my_list[i-1]
    diff_list.append(x)
  </p>
  <p>print(diff_list)</p>
  <hr>
  <p>
    schöner
    diffs = [y - x for x, y in zip(my_list, my_list[1:])]
  </p>
  